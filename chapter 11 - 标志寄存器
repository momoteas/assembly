1）CPU内部的寄存器中，有一种特殊的寄存器，称为标志寄存器。具有三种作用：
        1> 用来存储相关指令的某些执行结果；
        2> 用来为CPU执行相关指令提供行为依据；
        3> 用来控制CPU的相关工作方式；
        8086CPU的标志寄存器有16位，其中存储的信息通常称为状态字（PSW）。本章中的标志寄存器（以下简称为flag）；
           flag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而flag寄存器是按位起作用的，也就是说，它的每一位都有专
        门的含义，记录特定的信息；
           flag的1,3,5,12,13,14,15位在8086CPU中没有使用，不具有任何含义。而0,2,4,6,7,8,9,10,11位都具有特殊的含义；
           图11.1 flag寄存器各位示意：
        15      14      13      12      11      10      9       8       7       6       5       4       3       2       1       0
                                        OF      DF      IF      TF      SF      ZF              AF              PF              CF
                                        
11.1 ZF标志：
        1> flag的第6位是ZF，零标志位。它记录相关指令执行后，其结果是否为0.如果结果为0，那么ZF=1，如果结果不为零，那么ZF=0;
           注意，在8086CPU的指令集中，有的指令的执行时影响标志寄存器的，比如：add, sub, mul, div, inc, or, and等，它们大都是运算指令（进行逻辑
        或算术运算）；有的指令的执行对标志寄存器没有影响，比如：mov, push, pop等，它们大都是传送指令。我们在使用一条指令的时候，要注意这条指令的全
        部功能，其中包括，执行结果对标志寄存器的那些标志位造成的影响；
        
11.2 PF标志：
        1> flag的第2位是PF，奇偶标志位。它记录相关指令执行后，其结果的所有二进制位中1的个数是否为偶数。如果1的个数为偶数，PF=1，如果为奇数，那么
        PF=0；

11.3 SF标志：
        1> flag的第7位是SF，符号标志位。它记录相关指令执行后，其结果是否为负。如果结果为负，SF=1，如果非负，SF=0；
        2> 不管我们如何看待，CPU在执行add等指令的时候，就已经包含了两种含义，也将得到用同一种信息来记录的两种结果。关键在于我们的程序需要哪一种结果；
        3> SF标志，就是CPU对有符号数运算的结果的一种记录，它记录数据的正负。在我们将数据当作有符号来运算的时候，可以通过它来得知结果的正负。如果我们
        将数据当作无符号数来运算，SF的值则没有意义，虽然相关的指令影响了它的值；
        4> 某些指令将影响标志寄存器中的多个标志位，这些被影响的标记位比较全面地记录了指令的执行结果，为相关的处理提供了所需的依据；

11.4 CF标志：
        1> flag的第0位是CF，进位标志位。一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高的进位值，或从更高位的借位值；
        2> 而当两个数据做减法的时候，有可能向更高位借位，而flag的CF位也可以用来记录这个借位值；
        
11.5 OF标志：
        1> 溢出：在进行有符号数运算的时候，如结果超出了机器所能表示的范围称为溢出；
        2> 那么，什么是机器所能表示的范围呢？比如说，对于8位的有符号数据，机器所能表示的范围就是 -128 ~ 127。同理，对于16位有符号数，机器所能表示
        的范围是 -32768 ~ 32767。如果运算结果超出了机器所能表达的范围，将产生溢出；
        3> flag的第11位是OF，溢出标志位。一般情况下，OF记录了有符号数运算的结果是否发生了溢出。如果发生溢出，OF=1，如果没有，OF=0；
        4> 一定要注意CF和OF的区别：CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位；
        
11.6 adc指令：
        1> adc是带进位加法指令，它利用了CF位上记录的进位值；
        2> 指令格式：adc 操作对象1， 操作对象2；
        3> 功能：操作对象1=操作对象1 + 操作对象2 + CF；
        4> 我们先来看一下CF的值的含义。在执行adc指令的时候加上的CF的值的含义，由adc指令前面的指令决定的，也就是说，关键在于所加上的CF值是被什么
        指令设置的。显然，如果CF的值是被sub指令设置的，那么它的含义就是借位值；如果是被add指令设置的，那么它的含义就是进位值；
        5> 看了CPU提供adc指令的目的，就是来进行加法的第二步运算的。adc指令和add指令相配合就可以对更大的数据进行加法运算；

11.7 sbb指令：
        1> sbb是带借位减法指令，它利用了CF位上记录的借位信息；
        2> 指令格式：sbb 操作对象1， 操作对象2；
        3> 功能：操作对象1 = 操作对象1 - 操作对象2 - CF；
        4> sbb指令执行后，将对CF进行设置。利用sbb指令我们可以对任意大的数据进行减法运算；
        
11.8 cmp指令：
        1> cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响。其他相关指令通过识别这些被影响的标志寄存器
        位来得知比较结果；
        2> cmp指令格式： cmp 操作对象1， 操作对象2；
        3> 功能：设置操作对象1 - 操作对象2， 但并不保存结果，仅仅依据计算结果对标志寄存器进行设置；
        4> 现在我们可以看出比较指令的设计思路，即：通过做减法运算，影响标志寄存器，标志寄存器的相关位记录了比较的结果；
        5> 同add, sub指令一样，CPU在执行cmp指令的时候，包含两种含义：进行无符号数运算和进行有符号数运算；
        6> 从上面的分析中，我们知道，实际结果的正负，之所以不能说明逻辑上真正结果的正负，关键的原因在于发生了溢出。如果没有溢出发生的话，那么实际
        结果的正负和逻辑上真正结果的正负就一致了。所以，我们应该在考察SF（得知实际结果的正负）的同时考察OF（得知有没有溢出），就可以得知逻辑上真
        正结果的正负，同时就可以知道比较的结果；
        7> 下面，我们以cmp ah, bh为例，总结一下CPU执行cmp指令后，SF和OF的值是如何来说明比较的结果的：
        
        
        
        
        
        
        

