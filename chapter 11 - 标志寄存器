1）CPU内部的寄存器中，有一种特殊的寄存器，称为标志寄存器。具有三种作用：
        1> 用来存储相关指令的某些执行结果；
        2> 用来为CPU执行相关指令提供行为依据；
        3> 用来控制CPU的相关工作方式；
        8086CPU的标志寄存器有16位，其中存储的信息通常称为状态字（PSW）。本章中的标志寄存器（以下简称为flag）；
           flag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而flag寄存器是按位起作用的，也就是说，它的每一位都有专
        门的含义，记录特定的信息；
           flag的1,3,5,12,13,14,15位在8086CPU中没有使用，不具有任何含义。而0,2,4,6,7,8,9,10,11位都具有特殊的含义；
           图11.1 flag寄存器各位示意：
        15      14      13      12      11      10      9       8       7       6       5       4       3       2       1       0
                                        OF      DF      IF      TF      SF      ZF              AF              PF              CF
                                        
11.1 ZF标志：
        1> flag的第6位是ZF，零标志位。它记录相关指令执行后，其结果是否为0.如果结果为0，那么ZF=1，如果结果不为零，那么ZF=0;
           注意，在8086CPU的指令集中，有的指令的执行时影响标志寄存器的，比如：add, sub, mul, div, inc, or, and等，它们大都是运算指令（进行逻辑
        或算术运算）；有的指令的执行对标志寄存器没有影响，比如：mov, push, pop等，它们大都是传送指令。我们在使用一条指令的时候，要注意这条指令的全
        部功能，其中包括，执行结果对标志寄存器的那些标志位造成的影响；
        
11.2 PF标志：
        1> flag的第2位是PF，奇偶标志位。它记录相关指令执行后，其结果的所有二进制位中1的个数是否为偶数。如果1的个数为偶数，PF=1，如果为奇数，那么
        PF=0；

11.3 SF标志：
        1> flag的第7位是SF，符号标志位。它记录相关指令执行后，其结果是否为负。如果结果为负，SF=1，如果非负，SF=0；
        2> 不管我们如何看待，CPU在执行add等指令的时候，就已经包含了两种含义，也将得到用同一种信息来记录的两种结果。关键在于我们的程序需要哪一种结果；
        3> SF标志，就是CPU对有符号数运算的结果的一种记录，它记录数据的正负。在我们将数据当作有符号来运算的时候，可以通过它来得知结果的正负。如果我们
        将数据当作无符号数来运算，SF的值则没有意义，虽然相关的指令影响了它的值；
        4> 某些指令将影响标志寄存器中的多个标志位，这些被影响的标记位比较全面地记录了指令的执行结果，为相关的处理提供了所需的依据；

11.4 CF标志：
        1> flag的第0位是CF，进位标志位。一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高的进位值，或从更高位的借位值；
        2> 而当两个数据做减法的时候，有可能向更高位借位，而flag的CF位也可以用来记录这个借位值；
        
11.5 OF标志：
        1> 溢出：在进行有符号数运算的时候，如结果超出了机器所能表示的范围称为溢出；
        2> 那么，什么是机器所能表示的范围呢？比如说，对于8位的有符号数据，机器所能表示的范围就是 -128 ~ 127。同理，对于16位有符号数，机器所能表示
        的范围是 -32768 ~ 32767。如果运算结果超出了机器所能表达的范围，将产生溢出；
        3> flag的第11位是OF，溢出标志位。一般情况下，OF记录了有符号数运算的结果是否发生了溢出。如果发生溢出，OF=1，如果没有，OF=0；
        4> 一定要注意CF和OF的区别：CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位；
        
11.6 adc指令：
        1> adc是带进位加法指令，它利用了CF位上记录的进位值；
        2> 指令格式：adc 操作对象1， 操作对象2；
        3> 功能：操作对象1=操作对象1 + 操作对象2 + CF；
        4> 我们先来看一下CF的值的含义。在执行adc指令的时候加上的CF的值的含义，由adc指令前面的指令决定的，也就是说，关键在于所加上的CF值是被什么
        指令设置的。显然，如果CF的值是被sub指令设置的，那么它的含义就是借位值；如果是被add指令设置的，那么它的含义就是进位值；
        5> 看了CPU提供adc指令的目的，就是来进行加法的第二步运算的。adc指令和add指令相配合就可以对更大的数据进行加法运算；

11.7 sbb指令：
        1> sbb是带借位减法指令，它利用了CF位上记录的借位信息；
        2> 指令格式：sbb 操作对象1， 操作对象2；
        3> 功能：操作对象1 = 操作对象1 - 操作对象2 - CF；
        4> sbb指令执行后，将对CF进行设置。利用sbb指令我们可以对任意大的数据进行减法运算；
        
11.8 cmp指令：
        1> cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响。其他相关指令通过识别这些被影响的标志寄存器
        位来得知比较结果；
        2> cmp指令格式： cmp 操作对象1， 操作对象2；
        3> 功能：设置操作对象1 - 操作对象2， 但并不保存结果，仅仅依据计算结果对标志寄存器进行设置；
        4> 现在我们可以看出比较指令的设计思路，即：通过做减法运算，影响标志寄存器，标志寄存器的相关位记录了比较的结果；
        5> 同add, sub指令一样，CPU在执行cmp指令的时候，包含两种含义：进行无符号数运算和进行有符号数运算；
        6> 从上面的分析中，我们知道，实际结果的正负，之所以不能说明逻辑上真正结果的正负，关键的原因在于发生了溢出。如果没有溢出发生的话，那么实际
        结果的正负和逻辑上真正结果的正负就一致了。所以，我们应该在考察SF（得知实际结果的正负）的同时考察OF（得知有没有溢出），就可以得知逻辑上真
        正结果的正负，同时就可以知道比较的结果；
        7> 下面，我们以cmp ah, bh为例，总结一下CPU执行cmp指令后，SF和OF的值是如何来说明比较的结果的：
                1）如果 SF=1，而OF=0：
                   OF=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负
                2）如果SF=1， 而OF=1
                   OF=1，说明有溢出，逻辑上真正结果的正负 ！= 实际结果的正负；
                   因SF=1，实际结果为负；
                3）如果SF=0，而OF=1：
                   OF=1，说明有溢出，逻辑上真正结果的正负 ！= 实际结果的正负；
                4）如果SF=0，而OF=0：
                   OF=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负；
        
11.9 检测比较结果的条件转移指令：
        1）“转移”指的是它能够修改IP，而“条件”指的是它可以根据某种条件，决定是否修改IP；
        2）除了jcxz之外，CPU还提供了其他条件转移指令，大多数条件转移指令都检测标志寄存器的相关标志位，根据检测的结果来决定是否修改IP。它们检测的
        是哪些标志位呢？就是被cmp指令影响的哪些，表示比较结果的标志位。这些条件转移指令通常都和cmp配合使用，就好像call和ret指令通常相配合使用一样。
        因为cmp指令可以同时进行两种比较，无符号数比较和有符号数比较，所以根据cmp指令的比较结果进行转移的指令也可分为两种：
                1> 根据无符号数的比较结果进行转移的条件转移指令，它们检测ZF、CF的值；
                2> 根据有符号数的比较结果进行转移的条件转移指令，它们检测SF、OF和ZF的值；
        3）表11.1是常用的根据无符号数的比较结果进行转移的条件转移指令：
        
                指令                      含义                              检测的相关标志位
                je                        等于则转移                         ZF=1
                jne                       不等于则转移                       ZF=0
                jb                        低于则转移                         CF=1
                jnb                       不低于则转移                       CF=0
                ja                        高于则转移                         CF=0且ZF=0
                jna                       不高于则转移                       CF=1或ZF=1
          至于究竟在je之前使不使用cmp指令，在于我们的安排。je检测的是ZF位置，不管je前面是什么指令，只要CPU执行je指令时，ZF=1，那么就会发生转移；              
        
11.10 DF标志和串传送指令：        
        1）flag的第10位是DF，方向标志位。在串处理指令中，控制每次操作后si, di的增减。
                1> DF=0 每次操作后si, di递增；
                2> DF=1 每次操作后si, di递减；
        2）串传送指令：
                1> 格式：movsb
                2> 功能：执行movsb指令相当于进行下面几步操作：
                        <1 ((cs)*16+(di))=((ds)*16+(si))
                        <2 如果DF=0 则：（si）=(si)+1
                                        (di) =(di)+1
                           如果DF=1 则：（si）=(si)-1
                                        (di) =(di)-1
                           我们可以用汇编语法描述movsb的功能：
                                mov es:[di], byte ptr ds:[si]
                                可以看出，movsb的功能是将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器DF的值，将si和di递增或递减；
                        <3 当然，也可以传送一个字，格式为：movsw; 功能是将ds:si指向的内存单元中word送入es:di中，然后根据标志寄存器DF位的值，将
                        si和di递增2或递减2；
                        <4 movsb和movsw进行的是串传送操作中的一个步骤，一般来说，movsb和movsw都和rep配合使用，格式如下：rep movsb，用汇编语法
                        来描述rep movsb的功能就是：
                                s: movsb
                                   loop s
                           可见，rep的作用是根据cx的值，重复执行后面的串传送指令。由于每执行一次movsb指令si和di都会递增或递减指向后一个单元或前
                        一个单元，则rep movsb就可以循环实现（cx）个字符的传送；
                        <5 由于flag的DF位决定着串传送指令执行后，si和di改变的方向，所以CPU应该提供相应的指令来对DF位进行设置，从而使程序员能够决
                        定传送的方向。8086CPU提供下面两条指令对CPU位进行设置：
                                cld指令：将标准寄存器的DF位置0；
                                std指令：将标志寄存器的DF位置1；
                        <6 使用串传送指令进行数据的传送，需要给它提供一些必要的信息，它们是：
                                /1 传送的原始位置：ds:si;
                                /2 传送的目的位置：es:di;
                                /3 传送的长度：cx;
                                /4 传送的方向：DF；
11.11 push和popf:
        1) pushf的功能是将标志寄存器的值压栈，而popf是从栈中弹出数据，进入标志寄存器中。pushf和popf为直接访问标志寄存器提供了一种方法；
        
11.12 标志寄存器在Debug中的表示：
        1）在Debugz中，标志寄存器是按照有意义的各标志位单独表示的。下面列出Debug对我们已知的标志位的表示：
                标志              值为1的标记                  值为0的标记
                OF                OV                          NV
                SF                NG                          PL
                ZF                ZR                          NZ
                PF                PE                          PO
                CF                CY                          NC
                DF                DN                          UP
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
        

