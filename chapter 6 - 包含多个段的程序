6.1 在代码段中使用数据：
        1） 从规范的角度来讲，我们不能自己随便决定那段空间可以使用的，应让系统来为我们分配。我们可以在程序中，定义我们希望处理的数据，这些数据就会被
            编译、连接程序作为程序的一部分写到可执行文件中。当可执行文件中的程序被加载入内存时，这些数据也同时被加载入内存中。与此同时，我们要处理的
            数据也就自然而然地获得了存储空间；
         2）dw: 定义字型数据，所占的内存空间大小 16 byte;
         3) end作用：除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。例如： end start；
         4）现在的问题是，根据什么设置CPU的CS:IP指向程序的第一条要执行的指令？也就是说，如何知道那一条指令是程序的第一条要执行的指令？这一点，是由
            可执行文件中的描述信息指明的。我们知道可执行文件由描述信息和程序组成，程序来自于源程序中的汇编指令和定义的数据；描述信息则主要是编译、连
            接程序对源程序中的伪指令进行处理所得到的信息。我们在程序6.2中，用伪指令end描述了程序的结束和程序的入口。在编译连接后，由“end start”指明
            程序的入口，被转化为一个入口地址，存储在可执行文件的描述信息中。在程序6.2生成的可执行文件中，这个入口地址的偏移地址部分为：10H。当程序被
            加载入内存之后，加载者从程序的可执行文件的描述信息中读到程序的入口地址，设置CS:IP。这样CPU就从我们希望的地址处开始执行；
         5) 归根结底，我们若要CPU从何处开始执行程序，只要在程序中用“end 标号”指明就可以了。安排程序的框架：
                    assume cs:code
                    code segment
                            :
                            :
                            数据
                            ：
                            ：
                     start:
                            :
                            :
                            代码
                            ：
                     code ends
                     end start
                     
6.2 在代码段中使用段：
        1） 例如：  
                        assume cs:code
                        code segment
                                dw 0123H, 0456H, 0789H, 0abcH, 0defH, 0fedH, 0cbaH, 0987H
                                dw 0, 0, 0, 0, 0, 0, 0, 0       ; 用dw定义8个字型数据，在程序加载后，将取得8个字的内存空间，存放这8个数据；
                                
6.3 将数据、代码、栈放入不同的段：
        1） 用多个段来存放数据、代码和栈：怎么做呢？我们用和定义代码段一样的方法来定义多个段，然后在这些段里面定义需要的数据，或通过定义数据来取得
            栈空间；
        2） 定义多个段的方法：定义一个段的方法和我们前面所讲的定义代码段的方法没有区别，只是对于不同的段，要有不同的段名；
                        assume cs:codesg, ds:data, ss:stack
                        data segment
                                dw 0123H, 0456H, 0789H, 0abcH, 0defH, 0fedH, 0cbaH, 0987H
                        data ends
                        stack segment
                                dw 0, 0, 0, 0, 0, 0, 0, 0
                        stack ends
                        code segment
                                :
                                :
         3) 对段地址的引用：现在程序中有多个段了，我们如何访问段中的数据呢？当然要通过地址，而地址是分为两部分的，即段地址和偏移地址。我们如何指明
            要访问的数据的段地址呢？在程序中，段名就相当于一个标号，它代表了段地址。
         4） “伪码段”、“数据段”、“栈段”完全是我们的安排：我们 在源程序中用伪指令“assume cs:code, ds:data, ss:stack” 将cs, ds, ss分别和code, 
             data, stack段相连。这样做了之后，CPU是否就会将cs指向code, ds指向data, ss指向stack, 从而按照我们的意图来处理这些段呢？
         5） 总之，CPU到底如何处理我们定义的段中的内容，是当作指令执行，当作数据访问，还是当作栈空间，完全是靠程序中具体的汇编指令，和汇编指令对
             CS:IP, SS:SP, DS等寄存器的设置来决定的。
          
            


















