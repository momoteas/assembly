    任何一个通用的CPU，比如8086，都具备一种能力，可以在执行完当前正在执行的指令后，检测到从CPU外部发送过来的或内部产生的一种特殊信息，并且可以立即对
所接收到的信息进行处理。这种特殊的信息，我们可以称其为：中断信息。中断的意思是指：CPU不再接着（刚执行完的指令）向下执行，而是转去处理这个特殊信息；
    “中断信息”是要求CPU马上进行某种处理，并向所要进行的该种处理提供了必备的参数的通知信息；
    中断信息可以来自CPU的内部和外部，这一章，我们主要讨论来自CPU内部的中断信息；
    
12.1 内中断的产生：
        1）对于8086CPU，当CPU内部有下面的情况发生的时候，将产生相应的中断信息：
                1> 除法错误，比如：执行div指令产生的除法溢出；
                2> 单步执行；
                3> 执行int0指令；
                4> 执行int指令；
           既然是不同的信息，就需要进行不同的处理。要进行不同的处理，CPU首先要知道，所接收的中断信息的来源。所以，中断信息中必须包含识别来源的编码。
        8086CPU用称为中断类型码的数据来标识中断信息的来源。中断类型码是一个字节型数据，可以标识256种中断信息来源；
        2）8086CPU中的中断类型码如下：
                1> 除法错误：0
                2> 单步执行：1
                3> 执行int0指令：4
                4> 执行int指令，该指令的格式为int n, 指令中的n为字节型立即数，是提供给CPU的中断类型码；
                
12.2 中断处理程序：
        1）CPU收到中断信息后，需要对中断信息进行处理。而如何对中断信息进行处理，可以由我们编程决定。我们编写的，用来处理中断信息的程序被称为中断
        处理程序。一般来说，需要对不同的中断信息编写不同的处理程序；
        2）我们知道，若要8086CPU执行某处的程序，就要将CS:IP指向它的入口。可见，首要的问题是，CPU在收到中断信息后，如何根据中断信息确定其处理程序
        的入口；
        3）中断信息中含有标识中断源的类型码。根据CPU的设计，中断类型码的作用就是用来定位中断处理程序。比如CPU根据中断类型码4，就可以找到4号中断的
        处理程序。可随之而来的问题是，若要定位中断处理程序，需要知道它的段地址和偏移地址，而如何根据8位的中断类型码得到中断处理程序的段地址和偏移地
        址呢？

12.3 中断向量表：
        1）CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址；
        2）所谓中断向量，就是中断处理程序的入口地址；
        3）中断向量表在内存中保存，其中存放着256个中断源所对应的中断处理程序入口；
        4）对于8086CPU机，中断向量表指定放在内存地址0处。从内存0000:0000到0000:03E8个单元中存放着中断向量表；
        5）一个表项占多大的空间呢？一个表项存放一个中断向量，也就是一个中断处理程序的入口地址，对于8086CPU，这个入口地址包括段地址和偏移地址，所以
        一个表项占两个字，高地址字存放段地址，低地址字存放偏移地址；

12.4 中断过程：
        1）用中断类型码找到中断向量，并用它设置CS和IP，这个工作有CPU的硬件自动完成。CPU硬件完成这个工作的过程被称为中断过程；
        2）CPU收到中断信息后，要对中断信息进行处理，首先将引发中断过程。硬件在完成中断过程后，CS：IP将指向中断处理程序的入口，CPU开始执行中断处理程序；
        3）有一个问题需要考虑，CPU在执行完中断处理程序后，应该返回原来的执行点继续执行下面的指令。所以在中断过程中，在设置CS：IP之前，还要讲原来的CS和
        IP的值保存起来。在使用call调用子程序时也有同样的问题，子程序执行后还要返回原来的执行点继续执行，所以，call指令先保存当期CS的IP值，然后在设置
        CS和IP；
        4）下面是8086CPU在收到中断信息后，所引发的中断过程：
                1> （从中断信息中）取得中断类型码；
                2>  标准寄存器的值入栈；（因为在中断过程中要改变标志寄存器的值，所以先将其保存在栈中）
                3>  设置标志寄存器的第8位TF和第9位IF的值为0；（这一步的目的后面将介绍）
                4>  CS的内容入栈；
                5>  IP的内容入栈；
                6>  从内存地址为中断类型码*4和中断类型码*4+2的两个字单元中读取中断处理程序的入口地址IP和CS；
                
12.5 中断处理程序：
        1）中断处理程序的编写方法和子程序的比较相似，下面是常规的步骤：
                1> 保存用到的寄存器；
                2> 处理中断；
                3> 恢复用到的寄存器；
                4> 用iret指令返回；
        2）iret指令的功能用汇编语法描述为：
                pop IP
                pop CS
                popf
           iret通常和硬件自动完成的中断过程配合使用。可以看到，在中断过程中，寄存器入栈的顺序是标志寄存器、CS、IP，而iret的出栈顺序是IP、CS、标志
        寄存器，刚好和其相对，实现了用执行中断处理程序前的CPU现场恢复标志寄存器和CS、IP的工作。iret指令执行后，CPU回到执行中断处理程序前的执行点继
        续执行程序；
        
12.6 除法错误中断的处理：

12.7 编程处理0号中断：
        1）我们首先进行分析：
                1> 当发生除法溢出的时候，产生0号中断信息，从而引发中断过程。此时，CPU将进行以下工作：
                        <1 取得中断类型码0；
                        <2 标志寄存器入栈，TF、IF设置为0；
                        <3 CS、IP入栈；
                        <4 (IP)=(0*4), (CS)=(0*4+2);
                2> 可见，当中断0发生时，CPU将转去执行中断处理程序。只要按如下步骤编写中断处理程序，当中断0发生时，即可显示“overflow!”:
                        <1 相关处理；
                        <2 向显示缓冲区送字符串“oveflow!”;
                        <3 返回DOS；
                3> 现在的问题是：do0应存放在内存中。因为除法溢出随时可能发生，CPU随时都可能将CS：IP指向do0的入口，执行程序。那么do0应该放在那里呢？
                一般情况下，从0000:0200至0000:0300的256个字节的空间向量表项是空的，操作系统和其他应用程序都不占用；
                4> 我们将中断处理程序do0放到0000:0200后，若要使得除法溢出发生的时候，CPU转去执行，则必须将do0的入口地址，即0000:0200等级在中断向量
                表的对应表项中。因为除法溢出对应的中断类型码为0，它的中断处理程序的入口地址应该从0*4地址单元开始存放，段地址存放在0*4+2字单元中，偏
                移地址存放在0*4字单元中；
                   总结上面的分析，我们要做以下几件事情：
                            /1 编写可以显示“voerflow!”的中断处理程序：do0;
                            /2 将do0送入内存0000:0200处；
                            /3 将do0的入口地址0000:0200存储在中断向量表0号表项中；
























