1. [bx]和内存单元的描述：我们用[0]表示一个内存单元时，0表示单元的偏移地址，段地址默认在ds中，单元的长度（类型）可以由具体指令中的其他操作对象（比如说寄存器）指出；

2. loop: 

3. 我们定义的描述性的符号“（）”： 为了描述上的简洁，在以后的课程中，我们将使用一个描述性的符号“（）”来表示一个寄存器或一个内存单元的内容。比如：（ax）表示ax中的内容；

4. 约定符号idata表示常量： 


5.1 [bx]: 

5.2 loop指令：
        loop指令的格式是：loop标号，CPU执行loop指令的时候，要进行两步操作：（1）（cx）=（cx）-1；（2）判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行；
        通常，我们用loop指令来实现循环功能，cx中存放循环的次数；
        分析： （1）标号
                在汇编语言中，标号代表一个地址，程序5.1中有一个标号s。它实际上标识了一个地址，这个地址处有一条指令：add ax, ax
                (2) loop s
                CPU执行loop s的时候，要进行两步操作：
                        <1> (cx)=(cx)-1;
                        <2> 判断cx中的值，不为0则调至标号s所标识的地址处执行，如果为零则执行下一条指令；
        总结用cx和loop指令相配合实现循环功能的三个要点：
                （1）在cx中存放循环的次数；
                （2）loop指令中的标号地址要在前面；
                （3）要循环执行的程序段，要写在标号和loop指令的中间；
                
5.3 在Debug中跟踪用loop指令实现的循环程序：
        注意： 我们知道的，大于9FFFh的十六进制数据A000H、A001H、......、C000H等，在书写的时候都是以字母开头的。而在汇编源程序中，数据不能以字母开头，所以要在前面加0；
               “int 21”要用P命令执行；
               重复执行：（1）用P命令自动执行“loop 0012”，知道（cx）=0; （2）使用g 偏移地址；
               
5.4 Debug和汇编编译器Masm对指令的不同处理：
        Debug和编译器masm对形如“mov ax, [0]”这类指令在解释上是不同的。Debug将它解释为“[idata]”是一个内存单元，“idata”是内存单元的偏移地址；而编译器将“[idata]”解释为“idata”；
        目前的方法是：我们可将偏移地址送入bx寄存器中，用[bx]的方式来访问内存。例如：
                        mov ax, 2000h
                        mov ds, ax
                        mov bx, 0
                        mov al, [bx]
        或者，在“[]”的前面显示地给出段地址所在的段寄存器。例如
                        mov ax, 2000h
                        mov ds, ax
                        mov al, ds:[0]
                        
5.5 loop和[bx]的联合应用：
        应用变量：“mov al, [bx]”中的bx就可以看作一个代表内存单元地址的变量；
        
5.6 段前缀：这些出现在访问内存单元的指令中，用于显示地指明内存单元的段地址的“ds:”、“cs:”、“ss:”、“es:”，在汇编语言中称为段前缀；

5.7 一段安全的空间：一般PC机中，DOS方式下，DOS和其他合法的程序一般都不会使用0:200 ~ 0:300的256个字节的空间；

5.8 段前缀的使用：
                        
        
        
        
        
        
        
                
        





