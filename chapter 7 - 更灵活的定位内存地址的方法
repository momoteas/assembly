7.1 and 和 or 指令：
        1) and指令：逻辑与指令，按位进行与运算；
        2) or指令：逻辑或指令，按位进行或运算；

7.2 关于ASCII码：简单来说，所谓编码方案，就是一套规则，它约定了用什么样的信息来表示现实对象；

7.3 以字符形式给出的数据：在汇编语言中，用‘...’的方式指明数据是以字符的形式给出的，编译器将把它们转化为对应的ASCII码；

7.4 大小写转换的问题：

7.5 [bx+idata]:
        1) 在前面，我们用[bx]的方式来指明一个内存单元，我们还可以用一种更为灵活的方式来指明内存单元；[bx+idata]表示一个内存单元，它的偏移地址为
          （bx）+ idata(bx中的数值加上idata);
        2) 该指令也可以写成如下格式：
                        mov ax, [200+bx]
                        mov ax, 200[bx]
                        mov ax, [bx].200
                    
7.6 用[bx+idata]的方式进行数组的处理：

7.7 SI和DI:
        1) SI和DI是8086CPU中和bx功能相近的寄存器，SI和DI不能够分成两个8位寄存器来使用；
        2） 注意，在程序中，我们用16位寄存器进行内存单元之间的数据传送，一次复制2个字节，一共循环8次；
        
7.8 [bx+si]和[bx+di]: 
        1) mov ax, [bx+si]的含义：将一个内存单元的内容送入ax, 这个内存的长度为2字节，存放一个字，偏移地址为bx中的数值加上si中的数值，段地址在
           ds中；
           
7.9 [bx+si+idata]和[bx+di+idata]:
        1) [bx+si+idata]表示一个内存单元，它的偏移地址为（bx）+（si）+ idata，段地址在ds中；
        2）该指令也可以写成如下格式：
                                mov ax, [bx+200+si]
                                mov ax, [200+bx+si]
                                mov ax, 200[bx][si]
                                mov ax, [bx].200[si]
                                mov ax, [bx][si].200
         
7.10 不同的寻址方式的灵活应用：
        1）几种定位内存地址的方法：
                1> [idata]用一个常量来表示地址，可用于直接定位一个内存单元；
                2> [bx]用一个变量来表示内存地址，可用于间接定位一个内存单元；
                3> [bx+idata]用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元；
                4> [bx+si]用两个变量表示地址；
                5> [bx+si+idata]用两个变量和一个常量表示地址；
        2）程序中经常需要进行数据的暂存，可以使用内存。我们可以考虑将需要暂存的数据放到内存单元中，需要的时候，再从内存单元中恢复。但是，做法却有
           些麻烦，因为需要保存多个数据的时候，读者必须要记住数据存放在哪个单元中，这样数据容易混乱；
        3）一般来说，在需要暂存数据的时候，我们都应该使用栈；
        





