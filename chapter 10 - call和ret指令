1） call和ret指令都是转移指令，它们都修改IP, 或同时修改CS和IP。它们经常被共同用来实现子程序的设计；

10.1 ret和retf:
        1) ret指令用栈中的数据，修改IP的内容，从而实现近转移；
        2）retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移；
        3）CPU执行ret指令时，进行下面两步操作：
                1> (IP)=((ss)*16+(sp));
                2> (sp)=(sp)+2;
        4) CPU执行retf指令时，进行下面四步操作：
                1> (IP)=((ss)*16+(sp));
                2> (sp)=(sp)+2;
                3> (CS)=((ss)*16+(sp));
                4> (sp)=(sp)+2;
        5) 可以看出，如果我们用汇编语法来解释ret和retf指令，则：
                1> CPU执行ret指令时，相当于进行： POP IP;
                2> CPU执行retf指令时，相当于进行：POP IP, POP CS;
           
10.2 call指令：
        1）CPU执行call指令时，进行两步操作：
                1> 将当前的IP或CS和IP压入栈中；
                2> 转移；
                call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同；
             
10.3 依据位移进行转移的call指令
        1） call 标号，将当前的IP压栈后，转到标号处执行指令；
        2） CPU执行此种格式的call指令时，进行如下的操作：
                1> (sp)=(sp)-2
                   (ss)*16+(sp)=(IP)
                2> (IP)=(IP)+16位位移
                16位位移=“标号”处的地址-call指令后的第一个字节的地址；
                16位位移的范围为-32768 ~ 32767；
                16位位移由编译程序在编译时算出；

10.4 转移的目的地址在指令中的call指令：








