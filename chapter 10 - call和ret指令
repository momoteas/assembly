1） call和ret指令都是转移指令，它们都修改IP, 或同时修改CS和IP。它们经常被共同用来实现子程序的设计；

10.1 ret和retf:
        1) ret指令用栈中的数据，修改IP的内容，从而实现近转移；
        2）retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移；
        3）CPU执行ret指令时，进行下面两步操作：
                1> (IP)=((ss)*16+(sp));
                2> (sp)=(sp)+2;
        4) CPU执行retf指令时，进行下面四步操作：
                1> (IP)=((ss)*16+(sp));
                2> (sp)=(sp)+2;
                3> (CS)=((ss)*16+(sp));
                4> (sp)=(sp)+2;
        5) 可以看出，如果我们用汇编语法来解释ret和retf指令，则：
                1> CPU执行ret指令时，相当于进行： POP IP;
                2> CPU执行retf指令时，相当于进行：POP IP, POP CS;
           
10.2 call指令：
        1）CPU执行call指令时，进行两步操作：
                1> 将当前的IP或CS和IP压入栈中；
                2> 转移；
                call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同；
             
10.3 依据位移进行转移的call指令
        1） call 标号，将当前的IP压栈后，转到标号处执行指令；
        2） CPU执行此种格式的call指令时，进行如下的操作：
                1> (sp)=(sp)-2
                   (ss)*16+(sp)=(IP)
                2> (IP)=(IP)+16位位移
                16位位移=“标号”处的地址-call指令后的第一个字节的地址；
                16位位移的范围为-32768 ~ 32767；
                16位位移由编译程序在编译时算出；

10.4 转移的目的地址在指令中的call指令：
        1）指令“call far ptr 标号”实现的是段间转移：
                1> （sp）=(sp)-2
                    ((ss)*16+(sp))=(cs)
                    (sp)=(sp)-2
                    ((ss)*16+(sp))=(ip)
                2> (cs)=标号所在段的段地址
                  （ip）=标号在段中的偏移地址
                用汇编语法来解释，CPU执行指令“call far ptr 标号”时，相当于进行：
                        push cs
                        push ip
                        jmp far ptr 标号

10.5 转移地址在寄存器中的call 指令：
                1）指令格式：call 16位寄存器，功能：                
                        (sp)=(sp)-2
                        ((ss)*16+(sp))=(ip)
                        (ip)=(16位寄存器）
                        用汇编语法来解释，相当于进行：
                                push ip
                                jmp 16位寄存器
 
 10.6 转移地址在内存中的call 指令：
        1）转移地址在内存中的call 指令有两种格式：
                1> call word ptr 内存单元地址，用汇编语法来解释:
                        push ip
                        jmp word ptr 内存单元地址
                2> call dword ptr 内存单元地址，相当于：
                        push cs
                        push ip
                        jmp dword ptr 内存单元地址

10.7 call和ret的配合使用：
        1）我们来看一下CPU执行这个程序的主要过程：
                1> CPU将call指令的机器码读入，IP指向了call s后的指令mov bx, ax, 然后CPU执行call s指令，将当前的IP值（指令mov bx, ax的偏移
                   地址）压栈，并将IP的值改变标号s处的偏移地址；
                2> CPU从标号s处开始执行指令，loop循环完毕后，（ax）=8;
                3> CPU将ret指令的机器码读入，IP指向了ret指令后的内存单元，然后CPU执行ret指令，从栈中弹出一个值（即call s先前压入的mov bx, ax
                   指令的偏移地址）送入IP中。则CS:IP指向指令mov bx, ax;
                4> CPU从mov bx, ax开始执行指令，直至完成；
       2）从上面的讨论中我们发现，可以写一个具有一定功能的程序段，我们成为子程序，在需要的时候，用call指令转去执行。可是执行完子程序后，如何让CPU
          接着call指令向下执行？call指令转去执行子程序之前，call指令后面的指令地址将存储在栈中，所以可在子程序的后面使用ret指令，用栈中的数据设
          置IP的值，从而转到call指令后面的代码处继续执行。这样，我们就可以利用call和ret指令来实现子程序的机制；
          
10.8 mul指令：
        1）mul是乘法指令，在使用mul做乘法的时候：
                1> 两个相乘的数：两个相乘的数，要么都是8位，要么都是16位。如果是8位，一个默认放在AH中，另一个放在8位寄存器或内存字节单元中；如果
                   是16位，一个默认在AX中，另一个放在16位寄存器或内存字单元中；
                2> 结果：如果是8位乘法，结果默认放在AX中；如果是16位乘法，结果高位默认在DX中存放，低位在AX中存放；
                
                   

